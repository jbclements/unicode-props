#lang racket

(require net/url
         file/sha1
         racket/runtime-path)

(define nat? exact-nonnegative-integer?)
(define range-list (listof (or/c nat? (cons/c nat? nat?))))

;; evaluating this file refreshes the unicode property predicates by
;; - downloading the required text files from unicode.org,
;; - comparing a hash of this file against the generated files,
;; - regenerating those source files if necessary, and
;; - regenerate main.rkt if any of the source files have changed.

;; specifies which properties we care about. 
;; a prop-file is (list/c source-file-name target-file-name (listof prop))
;; a prop is (list/c unicode-prop-name racket-prop-name)

;; this is (listof prop-file) :
(define prop-files
  `(("DerivedCoreProperties.txt"
     "derived-core-properties.rkt"
     (("XID_Start" "xid-start")
      ("XID_Continue" "xid-continue")))
    ("extracted/DerivedBinaryProperties.txt"
     "derived-binary-properties.rkt"
     (("Bidi_Mirrored"
       "bidi-mirrored")))))

(define force-rebuild? #f)

;; where to find the unicode text files:
;; (sadly, it seems unicode does not feel that the system
;; is stable enough to provide version-independent URLS
;; here. To go to a new version, change the version number
;; and hope that the new directory has the same format as
;; the old one.
(define unicode-url-stem
  "http://www.unicode.org/Public/UNIDATA/")

;; give up if the download of a given file takes more than this many seconds:
(define DOWNLOAD-TIMEOUT-SECS 60)

(define-runtime-path here ".")

;; rebuild source files if necessary, rebuild main.rkt if any of the source
;; files have changed
(define (go)
  (and (maybe-rebuild-source-files!)
       (rebuild-main!)))

;; rewrite the main.rkt file
(define (rebuild-main!)
  (log-info (~a "compute-prop: rebuilding main.rkt"))
  (with-output-to-file (build-path here "main.rkt")
    #:exists 'truncate
    (lambda ()
      (display "#lang racket\n")
      (display ";; this file is automatically generated\n\n")
      (define files 
        (for/list ([p prop-files])
          (~a (~s (second p)) "\n")))
      (display
       (apply ~a
       `( "(require " ,@files ")")))
      (newline)
      (display
       (apply ~a
       `( "(provide (all-from-out " ,@files "))"))))))

;; download unicode files, rebuild the corresponding racket files.
;; returrn 'true' if any of the source files were (re)built
(define (maybe-rebuild-source-files!)
  ;; can't use for/or here, we don't want short-cutting:
  ((lambda (x) (member #t x))
   (for/list ([record prop-files])
     (match-define (list source-file target-file props) record)
     (log-info (~a "compute-prop: fetching unicode source file: " source-file))
     (define ucd-file (fetch-file source-file))
     (log-info (~a "compute-prop: downloaded file to path: " ucd-file))
     (define hash (call-with-input-file ucd-file sha1))
     (log-info (~a "compute-prop: file has hash: " hash))
     (define target-path (build-path here target-file))
     (begin0
       (cond [(file-exists? target-path)
              (cond [(or (out-of-date? target-path hash)
                         force-rebuild?)
                     (log-info (~a "compute-prop: "
                                   "rebuilding source file: "
                                   target-path))
                     (delete-file target-path)
                     (build-source-file ucd-file hash 
                                        target-path props)]
                    [else
                     (log-info (~a "compute-prop: "
                                   "file was already up to date"))
                     #f])]
             [else
              (log-info
               (~a "compute-prop: building source file: " target-path))
              (build-source-file ucd-file hash target-path props)])
       (log-info (~a "compute-prop: deleting temp file: "ucd-file))
       (delete-file ucd-file)))))

;; given a path to the UCD text file, the hash of that file,
;; the path of the target (rkt) files, and the prop info, 
;; construct the target file. returns true.
;; EFFECT : writes the named target-path
(define (build-source-file ucd-file-path hash target-path props)
  (define range-sexps
    (for/list ([p props])
      (match-define (list prop-name fn-symbol) p)
      `(define-fn-and-ranges 
         ,(string->symbol (~a fn-symbol "-codepoints"))
         ,(string->symbol (~a fn-symbol "-codepoint?"))
         ,(membership-ranges ucd-file-path prop-name))))
  (call-with-output-file target-path
    (lambda (port)
      ;; this feels dirty, somehow... :)
      (display
       (~a "#lang racket\n"
           ";; HASH "hash"\n"
           ";; this file is automatically generated.\n"
           "\n"
           "(provide (all-defined-out))\n"
           "(require \"fn-and-ranges.rkt\")"
           "\n"
           )
       port)
      (for ([r range-sexps])
        (pretty-write r port))))
  #t)

;; given a file in the unicode UCD directory, fetch it to a temp file and return the name:
(define (fetch-file text-file-name)
  (define temp-f (make-temporary-file))
  (define url (string->url (~a unicode-url-stem text-file-name)))
  (call-with-output-file temp-f
    #:exists 'truncate
    (lambda (op)
      (define (destroy-file!)
        (close-output-port op)
        (delete-file temp-f))
      (define download-successful? (box #f))
      (define download-thread
        (thread
         (lambda ()
           (define-values (port headers)
             (get-pure-port/headers url #:status? #t))
           (unless (status-200? headers)
             (error 
              'fetch-file
              "expected successful http response for URL ~e, got: ~e"
              (url->string url)
              headers))
           (copy-port (get-pure-port url) op)
           (set-box! download-successful? #t))))
      (match (sync/timeout DOWNLOAD-TIMEOUT-SECS download-thread)
        [#f 
         ;; it timed out:
         (kill-thread download-thread)
         (destroy-file!)
         (error 'fetch-file 
                "timeout while downloading file: ~e"
                (url->string url))]
        [other
         (cond [(unbox download-successful?)
                #t]
               [else
                (destroy-file!)
                (error 'fetch-file
                       "download thread halted unsuccessfully")])])))
  temp-f)

;; does the header string begin with status 200 (ok) ?
(define (status-200? header-bytes)
  (regexp-match #px#"^HTTP/[0-9.]+ 200" header-bytes))

;; path-string string -> (listof (or/c nat? (cons/c nat? nat?)))
;; given a file and a character class mentioned in the file,
;; return an s-exp representing the code-point ranges
;; that are members of the class.
(define (membership-ranges temp-path char-class-name)
  (define line-regexp
    (pregexp (string-append "^([0-9A-Fa-f .\t]*); *" 
                            (regexp-quote char-class-name)
                            "[[:blank:]]*#")))
  (call-with-input-file temp-path
    (lambda (ip)
      (for/list ([line (in-lines ip)]
                 #:when (regexp-match line-regexp line))
        (match-define (list _ char-range) 
          (regexp-match line-regexp line))
        (match char-range
          [(regexp 
            #px"^([[:xdigit:]]+)\\.\\.([[:xdigit:]]+)\\w*"
            (list _ pre post))
           (cons (hex->num pre) (hex->num post))]
          [(regexp #px"^([[:xdigit:]]+)\\w*"
                   (list _ only))
           (hex->num only)])))))


;; given a hex number string, return a number
(define (hex->num str)
  (string->number str 16))


;; given a target-path and a hash, return true if the given
;; file's hash is not equal to the given hash
(define (out-of-date? target-path expected-hash)
  (call-with-input-file target-path
    (lambda (port)
      (define line1 (read-line port))
      (define expected-line1 "#lang racket")
      (unless (string=? line1 expected-line1)
        (error 'out-of-date "expected first line to be ~s, got ~e"
               expected-line1 line1))
      (define line2 (read-line port))
      (match line2
        [(regexp #px"^;; HASH ([[:xdigit:]]+)$"
                 (list _ hash))
         (log-info (~a "compute-prop: existing file has hash: "(~e hash)))
         (not (string=? expected-hash hash))]
        [other
         (error 'out-of-date "expected second line to match hash-regexp, got: ~e"
                other)]))))


(go)

#;(define xid-start-fn 
  `(define xid-start-code-point? 
     ,(membership-fn "XID_Start")))
#;(define xid-continue-fn (membership-fn "XID_Continue"))

(module* test racket
  ;; don't run this file during testing.
  )